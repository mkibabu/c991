PROJECT STRUCTURE

Package Client
- presents the client view of the game.
	Game.java
	- An all-or-nothing gambling game. The player casts a die (simulated by a
	random int generator with a range [1-6]). If the result is smaller than or
	equal to 3, the player loses all points, and the result is 0. Else, the
	player gains the maximum number of points available (6).
	The player sends the input and output to the Server, as well as the id of
	the current iteration, and the id of the ranch executed during the current
	iteration, to the server.
	
Package Server
- presents the server's view of the game.
	ClientState.java
	- object that encapsulates the current state of the client, as seen by the
	server. It represents a single execution fragment, i.e. the code executed
	between a consecutive SEND/RECV calls in the system. Each ClientState(i) is
	created from the i(th) message msg(i) receivef  by the server from the
	client.
	
	ServerGame.java
	- Server's view of the game. Consists of an executeBranch method that can
	recreate the client's current execution fragment, as presented by the
	ClientState object. It confirms the client's output, taking the input into
	consideration.
	
	BranchState.java
	- Alternate view of the server's perspective of the game.
	
	Verifier.java
	- Main class on the server. Contains two maps, one of valid clients and
	another for invalid clients. The maps are indexed by an int, client id. The
	value of the map is an ordered list of ClientState objects related to the
	key/client. As an ordered list, these make up an execution prefix, created
	from the trace of messages sent by the client.
	- The Verifier class receives the messages sent by the client. For each
	message msg(i), it creates a ClientState(i) and uses the serverGame to
	verify that the output is correct***. Once this is done, it appends the
	ClientState to the correct map. If the ClientState is invalid, that Client's
	ordered set of ClientStates (the execution prefix) is then further examined
	for errors.
	
	*** This method was to be one of the "hooks" that initiate and run the
	.jpf verification script. Here, the values fed into the script would be the
	client's input and output; they would be used to set the parameters of the
	symbolic method under test, and compared against the path condition (PC)
	generated by the jpf symbolic executor. 
	
	BackupIterator.java
	- This is the class that tests the invalid client's execution prefix. By
	iterating over the client's execution prefix, the iterator can test and
	verify each preceding client state message until it gets to the first
	invalid state occurrence. This would involve using the .jpf file to
	test each ClientState's output against the Path Conditions of the branch
	that the ClientState claims to have executed.
	
	ServerGame.jpf and BranchState.jpf
	- These are the .jpf files that generate and print out the path conditions
	of each branch of the game. Each .jpf file acts upon it's corresponding
	server.*.java file. BranchState.jpf represents a later iteration of
	ServerGame, and creates an easier-to-follow, less verbose output for each
	branch.
	
Libraries
The Game system is compiled using the jpf-core and jpf-symbc libraries. Steps
to obtain these can be found at:

http://bluegulf.wordpress.com/2011/04/20/tutorial-
using-java-pathfinder-together-with-junit-in-eclipse-environment-setup/

(a little dated, but still relevant in creating the libraries themselves)

http://babelfish.arc.nasa.gov/trac/jpf/wiki/projects/jpf-symbc/doc

(lacking in depth, but a good start anyway)
	
	